#### HTTP和HTTPS

> HTTP:超文本传输协议，默认端口80（它是用一种明文的方式发送我们的内容，不加密的）
>
> HTTPS：HTTP+SSL安全协议，默认端口号443，更加安全
>
> ​				（SSL是提供数据安全和完整性的协议，访问时先和服务器建立一个安全的连接通道，然后服务器会先发送一份网站的证书信息给我们电脑，相当于告诉我们你访问的网站没有问题，确认了信息之后，服务器会生成一个加锁的箱子，一把是给我们电脑的，一把是给服务器的；然后服务器把没有加锁的箱子和钥匙发给电脑，我们把信息放在箱子里面之后，锁上，发送给服务器，服务器用自己的钥匙打开来保证信息的安全）
>
>  
>
> 浏览器发送请求的过程
>
> > 在浏览器的地址栏中输入url，并发送请求，然后获取相应的响应内容（js，css等）然后进行渲染

#### 域名解析

> `DNS`解析将输入的网址解析成`IP`地址。
>
> `DNS`解析是一个递归查询的过程，例如要解析`“www.baidu.com”`时，过程如下：
>
> 1. 在本地域名服务器中查询`IP`地址，未找到域名；
> 2. 本地域名服务器会向根域名服务器发送请求，未找到域名；
> 3. 本地域名服务器向`.com`顶级域名服务器发送请求，未找到域名；
> 4. 本地域名服务器向`.baidu.com`域名服务器发送请求，找到该域名，将相应的`IP`返回给本地域名服务器；
>
> 

#### TCP连接的三次握手

> 在拿到服务器的`IP`地址后，客户端浏览器会与服务器建立`TCP`连接，该过程包括三次握手：
>
> 第一次握手：建立连接时，客户端向服务端发送请求报文`（SYN）`
>
> 第二次握手：服务器收到请求报文后，如同意连接，则向客户端发送确认报文`（SYN/ACK）`
>
> 第三次握手：客户端收到服务器的确认后，再次向服务器发送确认报文，完成连接`（ACK）`
>
> > 三次握手主要是为了防止已经失效的请求报文字段发送给服务器，浪费资源。
>
>
> 

#### 缓存实现

> - **强制缓存**
>
> ​	文件直接从缓存中得到，不需要发送请求
>
> ​	文件有过期时间（响应头 cache-control ）
>
> > ##### cache-control
> >
> > - max-age: 缓存过期时间，是一个相对时间
> > - public: 表示客户端和代理服务器都会缓存
> > - private: 表示只在客户端缓存
> > - no-cache: 协商缓存标识符，表示文件会被缓存但是需要和服务器协商
> > - no-store: 表示文件不会被缓存
>
> - **协商缓存**
>
>   意思是文件已经被缓存了，但是否从缓存中读取需要和服务器协商，具体如何协商要看请求头/响应头的字段设置。需要发送请求。
>
>   利用响应头Last-Modified/if-Modified-Since以及Etag/if-None-Match
>
>   > **Last-Modified/if-Modified-Since**
>   >
>   > - 浏览器第一次发送请求获取文件缓存下来，服务器响应头返回一个Last-Modified，记录被改动的时间
>   >
>   > - 浏览器第二次发送请求时会带上一个if-Modified-Since请求头，时间就是Last-Modified返回的值。然后服务器拿到这个字段和自己内部设置的时间进行对比，时间相同表示没有修改，就直接返回304，从缓存里面获取文件。
>   >
>   > **Etag/if-None-Match**
>   >
>   > - 由于 Last-Modified 的时间粒度是秒，有的文件在 1s 内可能被改动多次。这种方式在这种特殊情况下还是会失效，所以HTTP1.1又引入了 Etag 字段。这个字段是根据文件内容生成一个标记符比如"W/"5f9583bd-10a8""，然后再和 If-None-Match 进行对比就能更准确的知道文件有没有被改动过
>
>   ##### 何时缓存在memory,合适缓存在disk？
>
>   > 大文件会缓存在disk里面，因为内存也是有限的，磁盘的空间更大
>   >
>   > 小文件js、图片存的是memory
>   >
>   > css文件一般存在disk
>   >
>   > 特殊情况memory大小是有限制的，浏览器会根据自己的内置算法，将一部分js文件存到disk里面

#### 请求优化

> ##### 减少请求数量
>
> > - 将小图片打包成base64
> > - 利用雪碧图融合多个小图片
> > - 利用缓存
>
> ##### 减少请求时间
>
> > - 将js、css、html文件尽可能压缩，减少文件大小，加快下载速度
> > - 利用webpack打包根据路由进行懒加载，不要初始化就加载全部，那样文件会很大
> > - 能升级到高版本的http就升级到高版本
> > - 建立内部CDN能更快速的获取文件