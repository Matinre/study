#### HTTP和HTTPS

> HTTP:超文本传输协议，默认端口80（它是用一种明文的方式发送我们的内容，不加密的）
>
> HTTPS：HTTP+SSL安全协议，默认端口号443，更加安全
>
> ​				（SSL是提供数据安全和完整性的协议，访问时先和服务器建立一个安全的连接通道，然后服务器会先发送一份网站的证书信息给我们电脑，相当于告诉我们你访问的网站没有问题，确认了信息之后，服务器会生成一个加锁的箱子，一把是给我们电脑的，一把是给服务器的；然后服务器把没有加锁的箱子和钥匙发给电脑，我们把信息放在箱子里面之后，锁上，发送给服务器，服务器用自己的钥匙打开来保证信息的安全）
>
>  
>
> 浏览器发送请求的过程
>
> > 在浏览器的地址栏中输入url，并发送请求，然后获取相应的响应内容（js，css等）然后进行渲染

#### HTTPS—公私钥

> 网站持有私钥，用户持有公钥
>
> **非对称加密**：
>
>   1.网站用自己的私钥加密数据发给用户，用户用公钥解密数据。
>
>   2.用户发信息给网站，用户用公钥加密数据，网站用私钥解密数据
>
> 总结：
>
> ​	公钥是公开的，所以网站私钥加密的信息所有用户都可以看到。在这一个阶段，保护的其实是用户发给网站的数据，因为用户加密的信息只有服务器的私钥才可以解开。

#### HTTPS—数字证书

> **出现的原因**：如果有中间人黑客；用户访问网站时，网站将公钥发送给用户，在这一步，黑客将网站的公钥替换成自己的。这样，用户的信息都是由这个假公钥加密的，那么，所有的信息都可以被黑客破解（公钥私钥都是他的）
>
> 数字证书就是**CA私钥加密加密过的网站公钥**。（网站把公钥放到数字证书里面，用户可通过浏览器内置的CA公钥解密证书）

#### HTTPS—会话密钥

> 公私钥加密很安全，但是速度慢，每条信息都这么操作的话，会影响整个交流效率
>
> 所以在和https建立连接后，通过公私钥交换的信息只有一个：**会话密钥**。
>
> 会话密钥是对称加密，就是用了同一个密钥。

#### HTTPS—数字签名

> 1.用户将数据用摘要算法生成一个摘要
>
> 2.公钥加密摘要，作为签名
>
> 3.签名附加在内容后面，一起发送给服务端
>
> 4.服务端用私钥解密摘要
>
> 5.服务端用同样的摘要算法，得出摘要
>
> 6.两者比较，若一样，则内容完整，没有篡改

#### HTTPS—HTTPS握手流程

> - 客户端向网站发起请求
> - 网站将CA证书返回给客户端，证书里含有网站公钥
> - 客户端通过浏览器内置的CA公钥解密证书，拿到网站的公钥
> - 客户端生成随机的对称密钥—会话密钥
> - 客户端将会话密钥通过网站公钥加密，发送给网站
> - 网站和客户端可以通过会话密钥进行HTTP通信
>
> ![HTTPS工作流程](/picture/HTTPS工作流程.png)

#### 域名解析

> `DNS`解析将输入的网址解析成`IP`地址。
>
> `DNS`解析是一个递归查询的过程，例如要解析`“www.baidu.com”`时，过程如下：
>
> 1. 在本地域名服务器中查询`IP`地址，未找到域名；
> 2. 本地域名服务器会向根域名服务器发送请求，未找到域名；
> 3. 本地域名服务器向`.com`顶级域名服务器发送请求，未找到域名；
> 4. 本地域名服务器向`.baidu.com`域名服务器发送请求，找到该域名，将相应的`IP`返回给本地域名服务器；
>
> 

#### TCP连接的三次握手

> 在拿到服务器的`IP`地址后，客户端浏览器会与服务器建立`TCP`连接，该过程包括三次握手：
>
> 第一次握手：建立连接时，客户端向服务端发送请求报文`（SYN）`
>
> 第二次握手：服务器收到请求报文后，如同意连接，则向客户端发送确认报文`（SYN/ACK）`
>
> 第三次握手：客户端收到服务器的确认后，再次向服务器发送确认报文，完成连接`（ACK）`
>
> > 三次握手主要是为了防止已经失效的请求报文字段发送给服务器，浪费资源。
>
>
> 

#### 缓存实现

> - **强制缓存**
>
> ​	文件直接从缓存中得到，不需要发送请求
>
> ​	文件有过期时间（响应头 cache-control ）
>
> > ##### cache-control
> >
> > - max-age: 缓存过期时间，是一个相对时间
> > - public: 表示客户端和代理服务器都会缓存
> > - private: 表示只在客户端缓存
> > - no-cache: 协商缓存标识符，表示文件会被缓存但是需要和服务器协商
> > - no-store: 表示文件不会被缓存
>
> - **协商缓存**
>
>   意思是文件已经被缓存了，但是否从缓存中读取需要和服务器协商，具体如何协商要看请求头/响应头的字段设置。需要发送请求。
>
>   利用响应头Last-Modified/if-Modified-Since以及Etag/if-None-Match
>
>   > **Last-Modified/if-Modified-Since**
>   >
>   > - 浏览器第一次发送请求获取文件缓存下来，服务器响应头返回一个Last-Modified，记录被改动的时间
>   >
>   > - 浏览器第二次发送请求时会带上一个if-Modified-Since请求头，时间就是Last-Modified返回的值。然后服务器拿到这个字段和自己内部设置的时间进行对比，时间相同表示没有修改，就直接返回304，从缓存里面获取文件。
>   >
>   > **Etag/if-None-Match**
>   >
>   > - 由于 Last-Modified 的时间粒度是秒，有的文件在 1s 内可能被改动多次。这种方式在这种特殊情况下还是会失效，所以HTTP1.1又引入了 Etag 字段。这个字段是根据文件内容生成一个标记符比如"W/"5f9583bd-10a8""，然后再和 If-None-Match 进行对比就能更准确的知道文件有没有被改动过
>
>   ##### 何时缓存在memory,合适缓存在disk？
>
>   > 大文件会缓存在disk里面，因为内存也是有限的，磁盘的空间更大
>   >
>   > 小文件js、图片存的是memory
>   >
>   > css文件一般存在disk
>   >
>   > 特殊情况memory大小是有限制的，浏览器会根据自己的内置算法，将一部分js文件存到disk里面

#### 请求优化

> ##### 减少请求数量
>
> > - 将小图片打包成base64
> > - 利用雪碧图融合多个小图片
> > - 利用缓存
>
> ##### 减少请求时间
>
> > - 将js、css、html文件尽可能压缩，减少文件大小，加快下载速度
> > - 利用webpack打包根据路由进行懒加载，不要初始化就加载全部，那样文件会很大
> > - 能升级到高版本的http就升级到高版本
> > - 建立内部CDN能更快速的获取文件